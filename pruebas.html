<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const data = "carlos dalmau";

     //Paso 1, creas una función con la siguiente estructura

     /*function getData(){
        return data;
     }*/

     //Paso 2, si esa función llamara a bases de datos, la respuesta tardaría un poco en llegar, por lo que seguiría ejecutándose el código antes de tener la respuesta, por lo tanto, queremos especificar que el código no va a continuar hasta que nosotros no lo decidamos, creando una promesa:

     /*function getData(){
        return new Promise((resolve, reject)=>{})
     }*/

     //Paso 3, defines la lógica de la función, en la promesa ya no tendrás un return, tendrás un resolve, y reject será el return para cuando da "error".

      function getData() {
        return new Promise((resolve, reject) => {
          if (data.length == 0) {
            reject(new Error("Datos vacíos"));
          } else {
            setTimeout(() => {
              resolve(data);
            }, 1500);
          }
        });
      }

      //Esta es una forma de resolverlo, con .then y .catch para pillar el resolve y el reject
      //Esto se ejecuta cuando la función aún no se ha resuelto
      /*console.log(getData()
      .then((respuesta)=> console.log(respuesta))
      .catch((e)=>console.log(e)))*/

      //Se puede hacer con async y await
      async function devolverPromesa(){
      const datos = await getData();
      console.log(datos);
      }

      devolverPromesa();
    </script>
  </body>
</html>
